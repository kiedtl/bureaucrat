(use* core)
(use* varvara)

(use std)
(use alloc)
(use vec)

(test lang_Omit [
	(struct Fo [foo U8] [bar U16] [baz [U8]])
	(sizeof (Omit Fo baz)) (should eq 3)
])

(test lang_array_sizeof [
	(sizeof @[@Opaque])  (should eq 2)
	(sizeof [@Opaque 1]) (should eq 2)
	(sizeof [@Opaque 2]) (should eq 4)
	(sizeof [U8 2])      (should eq 2)
	(sizeof @[U8 2])     (should eq 2)
	(sizeof [@U8 2])     (should eq 4)
	(sizeof [U8 100])    (should eq 100)
	(sizeof [@U8 100])   (should eq 200)

	(struct Fee [fi U8] [fo [U16 2]] [fum @[Char8]])
	(sizeof Fee)         (should eq 7)
])

(test lang_decl_scoping [
	(word foobar [ 1 ])
	(word baz [
		(word foobar [ 2 ])
		foobar
	])
	foobar (should eq 1)
	baz    (should eq 2)
])

(test lang_type_scoping [
	(struct A [foo U8])
	(word baz [
		(struct A [foo U16] [bar U16] [baz U8])
		(sizeof A)
	])
	(sizeof A)  (should eq 1)
	baz         (should eq 5)
])

(test lang_stack_structs [
	(struct A [ foo U8 ])
	(struct B [ foo U16 ])
	(struct C [ foo U8 ] [ bar U8 ])

	0x24 (make A) :foo (should eq 0x24)

	1 2 3 0x24s (make B) drop (should eq 3)
	drop drop

	1 2 3 4 (make C) drop (should eq 2) (should eq 1)
	3 4 (make C) :foo (should eq 4)
	3 4 (make C) :bar (should eq 3)

	1 2 (make C) 3 4 (make C) swap :foo (should eq 2)
])

(test lang_monomorphic_var_static_alloc [
	(word variable (Type -- @$0) [
		(var _S $0)
		@_S
	])
	
	(of variable U8)  (as @U16)
	(of variable U16) (should neq)

	(of variable @U8) (as @U16)
	(of variable U16) (should neq)

	8 (of variable U8) <-
	(of variable U8) -> (should eq 8)

])

(word main [
])
