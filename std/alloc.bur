(use* core)
(use* varvara)
(use std)

# I wanted to have U16 guards, that way we could have 0x1cedc0fe
#
# Sadly that blows up the size to 9 bytes, so we have to settle with
# just lukewarm 0xc0fe
#
(struct Header
	[guard1 U8]
	[prev @Header]
	[next @Header]
	[free Bool]
	[guard2 U8]
)

(word first  (-- @Header) [ here (as @Header) ])

(word init ( -- ) [
	0s (as @Header)
		first :prev <-
	0xFFFFs (as @Header)
		first :next <-
	T       first :free <-
	0xc0    first :guard1 <-
	0xfe    first :guard2 <-
])

# ( block-count oldptr block-type -- (sizeof block-type)*block-count )
(word re ( U16 @$0 Type -- (Of Maybe0 @$0) ) [
	swap (sizeof $0) (as U16) * swap reget
	:value (make (Of Maybe0 @$0))
])

# ( block-count block-type -- (sizeof block-type)*block-count )
(word for ( U16 Type -- (Of Maybe0 @$0) ) [
	(sizeof $0) (as U16) * get
	:value (make (Of Maybe0 @$0))
])

# ( bytes -- *ptr )
(word get ( U16 -- (Of Maybe0 @Opaque) ) [
	(var size U16)
	@size <-

	#"*** Allocating " print-string
	#$size             print-dec
	#" bytes\n"        print-string

	first
	(while [
		#dup "Sz: " print-string chunk-size print-dec nl
		#    "Rq: " print-string $size print-dec nl
		#dup "Nx: " print-string :next -> print nl
		#dup "Av: " print-string :free -> print-bool nl
		#nl

		dup :free -> not
		swap-sb chunk-size $size <
		or
	] [
		#"    Skipping " print-string dup print nl

		dup :next -> 0= (when [
			0s (as @Opaque) (make (Of Maybe0 @Opaque))
			return
		])
		    :next ->
	])

	#"Chosen: " print-string dup print nl nl

	(var chosen @Header)
	@chosen <-


	nil $chosen :free <-

	$chosen chunk-size $size -
		(sizeof Header) (as U16) 1+
	< not (when [
		(var next @Header)
		(sizeof Header) (as U16) $size $chosen + + @next <-

		$chosen          $next   :prev <-
		$chosen :next -> $next   :next <-
		T                $next   :free <-
		$next            $chosen :next -> :prev <-
		$next            $chosen :next <-
		0xc0             $chosen :guard1 <-
		0xfe             $chosen :guard2 <-
	])

	$chosen (sizeof Header) (as @Opaque) +
	(make (Of Maybe0 @Opaque))
])

# ( bytes oldptr -- Maybe<newptr> )
(word reget (U16 @Opaque -- (Of Maybe0 @Opaque)) [
	(as @U8)
	dup get-header chunk-size
	rot
	# ( old old-sz new-sz )
	get :value dup 0= (when [ nip nip (make (Of Maybe0 @Opaque)) return ])
	# ( old old-chunk-sz new-unwrapped )
	rot 2dup (asm "s" .Op/Osth) (asm "s" .Op/Osth)
	# ( old-chunk-sz old new | new old )
	(as @U8) std/memcpy
	(asm "rs" .Op/Osth) (make (Of Maybe0 @Opaque))
	(asm "rs" .Op/Osth) (as @U8) de
])

(word de (AnyPtr16 -- ) [
	get-header
	#"Dealloc'ing: " print-string dup print nl

		dup     :guard1 -> 0xc0 <>
		over-sb :guard2 -> 0xfe <>
	or (when [ "Bad ptr" std/panic ])

	T swap-sb :free <-
])

(word get-header (@Opaque -- @Header) [
	(sizeof Header) (as U16) - (as @Header)
])

(word chunk-size (@Header -- U16) [
	dup :next -> swap -
	(sizeof Header) (as U16) -
])

(word defrag (--) [
	first
	(until [ :next -> 0= ] [
		dup     :free ->
		over-sb :next -> :free -> and
		(when [
			dup :next ->

			# current->next = next->next
			# ( current next )
			over :next
				# ( current next @current->next )
				over :next -> swap <-

			dup :next -> 0<> (when [
				# ( current next )
				:next ->
					# ( current $next->next )
					:prev
					# ( current $next->next->prev )
					over swap <-
					# ( current )

			] [ drop ])
		] [ :next -> ])
	])
])

(word print-chunk (@Header -- ) [
	dup print " \t" print-string
	dup :free -> print-bool "\t" print-string
	dup :prev -> print " \t" print-string
	dup :next -> print " \t" print-string
	dup chunk-size print-dec
	nl
	drop
])

(word print-chunks (--) [
	"Chunk\tFree\tPrev\tNext\tSize\n" print-string

	first
	(while [ :next -> 0<> ] [
		dup print-chunk
		:next ->
	])

	nl
])
