(use* core)
(use* varvara)
(use std)
(use burdampe)

// I wanted to have U16 guards, that way we could have 0x1cedc0fe
//
// Sadly that blows up the size to 9 bytes, so we have to settle with
// just lukewarm 0xc0fe
//
#private
(struct Header
	[guard1 U8]
	[prev @Header]
	[next @Header]
	[free Bool]
	[guard2 U8]
)

(word first  (-- @Header) [ here (as @Header) ])

(word init ( -- ) [
	0s (as @Header)
		first :prev <-
	0xFFFFs (as @Header)
		first :next <-
	T       first :free <-
	0xc0    first :guard1 <-
	0xfe    first :guard2 <-
	first (sizeof Header) (as U16) burdampe/protect
])

// ( block-count oldptr block-type -- (sizeof block-type)*block-count )
(word re ( U16 @$0 Type -- (Of std/Maybe0 @$0) ) [
	swap (sizeof $0) (as U16) * swap reget
	:value (make (Of std/Maybe0 @$0))
])

// ( block-count block-type -- (sizeof block-type)*block-count )
(word for ( U16 Type -- (Of std/Maybe0 @$0) ) [
	(sizeof $0) (as U16) * get
	:value (make (Of std/Maybe0 @$0))
])

// ( bytes -- *ptr )
(word get ( U16 -- (Of std/Maybe0 @Opaque) ) [
	(let size U16)
	@size <-

	first
	(while [
		dup :free -> not
		swap-sb chunk-size $size <
		or
	] [
		//    Skipping " print-string dup print nl

		dup :next -> 0= (when [
			0s (as @Opaque) (make (Of std/Maybe0 @Opaque))
			return
		])
		    :next ->
	])

	(let chosen @Header)
	@chosen <-
	burdampe/priv-enter
		nil $chosen :free <-
		burdampe/priv-exit

	$chosen chunk-size $size -
		(sizeof Header) (as U16) 1+
	< not (when [
		burdampe/priv-enter

		(let next @Header)
		(sizeof Header) (as U16) $size $chosen + + @next <-

		$chosen          $next   :prev <-
		$chosen :next -> $next   :next <-
		T                $next   :free <-
		$next            $chosen :next -> :prev <-
		$next            $chosen :next <-
		0xc0             $chosen :guard1 <-
		0xfe             $chosen :guard2 <-
	])

	$chosen (sizeof Header) (as @Opaque) +
	(make (Of std/Maybe0 @Opaque))
])

// ( bytes oldptr -- Maybe<newptr> )
(word reget (U16 @Opaque -- (Of std/Maybe0 @Opaque)) [
	(as @U8)
	dup get-header chunk-size
	rot
	// ( old old-sz new-sz )
	tuck min swap
	// ( old min(old-sz,new-sz) new-sz )
	get :value dup 0= (when [ nip nip (make (Of std/Maybe0 @Opaque)) return ])
	// ( old min-sz new-unwrapped )
	rot copy swap
	// ( min-sz old new )
	(as @U8) std/memcpy (make (Of std/Maybe0 @Opaque))
	(r move) de
])
(test alloc/reget_copies_correctly [
	init

	"Foo"
	dup std/strlen swap
	over get ;unwrap (as @U8)
	std/memcpy
	100s swap reget
	;unwrap

	"Foo" std/strequ (should eq t)
])

(word de (AnyPtr16 -- ) [
	get-header
	//Dealloc'ing: " print-string dup print nl

	//dup     :guard1 -> 0xc0 <>
	//over-sb :guard2 -> 0xfe <> or
		//(when [ "Invalid pointer" error-dealloc ])
	dup :free ->
		(when [ "Double-free" error-dealloc ])

	burdampe/priv-enter
		T swap-sb :free <-
		burdampe/priv-exit
	drop
])

// ( chunk chunk-header error-string )
#private #noreturn
(word error-dealloc ( AnyPtr16 AnyPtr16 @[U8] -- ) [
	print-string ": " print-string
	swap print
	" (Header: " print-string print ")\n" print-string
	print-chunks
	"Deallocation error" std/panic
])

(word get-header (@Opaque -- @Header) [
	(sizeof Header) (as U16) - (as @Header)
])

(word chunk-size (@Header -- U16) [
	dup :next -> swap -
	(sizeof Header) (as U16) -
])

(word defrag (--) [
	first
	(until [ :next -> 0= ] [
		dup     :free ->
		over-sb :next -> :free -> and
		(when [
			burdampe/priv-enter
			dup :next ->
			dup burdampe/unprotect

			// current->next = next->next
			// ( current next )
			over :next
				// ( current next @current->next )
				over :next -> swap <-

			dup :next -> 0<> (when [
				// ( current next )
				:next ->
					// ( current $next->next )
					:prev
					// ( current $next->next->prev )
					over swap <-
					// ( current )

			burdampe/priv-exit
		] [ :next -> ])
	]) drop
])

(word print-chunk (@Header -- ) [
	dup print " \t" print-string
	dup :free -> print-bool "\t" print-string
	dup :prev -> print " \t" print-string
	dup :next -> print " \t" print-string
	dup chunk-size print-dec
	nl
	drop
])

(word print-chunks (--) [
	"Chunk\tFree\tPrev\tNext\tSize\n" print-string

	first
	(while [ :next -> 0<> ] [
		dup print-chunk
		:next ->
	])

	nl
])

(test alloc/defrag [
	init
	
	(let ptrs [@Opaque 4])

	107s get ;unwrap drop
	107s get ;unwrap @ptrs :0 (as @@Opaque) <-
	10s  get ;unwrap @ptrs :1 (as @@Opaque) <-
	26s  get ;unwrap @ptrs :2 (as @@Opaque) <-
	2s   get ;unwrap drop
	30s  get ;unwrap drop
	30s  get ;unwrap @ptrs :3 (as @@Opaque) <-
	
	@ptrs :0 -> (as @Opaque) de
	@ptrs :1 -> (as @Opaque) de
	@ptrs :2 -> (as @Opaque) de
	@ptrs :3 -> (as @Opaque) de

	// XXX: will need to update if (sizeof Header) changes

	first
	dup :free -> (should eq nil) dup chunk-size (should eq 107s) :next ->
	dup :free -> (should eq t)   dup chunk-size (should eq 107s) :next ->
	dup :free -> (should eq t)   dup chunk-size (should eq  10s) :next ->
	dup :free -> (should eq t)   dup chunk-size (should eq  26s) :next ->
	dup :free -> (should eq nil) dup chunk-size (should eq   2s) :next ->
	dup :free -> (should eq nil) dup chunk-size (should eq  30s) :next ->
	dup :free -> (should eq t)   dup chunk-size (should eq  30s) :next ->
	dup :free -> (should eq t)
	:next -> (as U16) (should eq 0xFFFFs)

	defrag

	first
	dup :free -> (should eq nil) dup chunk-size (should eq 107s) :next ->
	dup :free -> (should eq t)   dup chunk-size (should eq 157s) :next ->
	dup :free -> (should eq nil) dup chunk-size (should eq   2s) :next ->
	dup :free -> (should eq nil) dup chunk-size (should eq  30s) :next ->
	dup :free -> (should eq t)
	:next -> (as U16) (should eq 0xFFFFs)
])
