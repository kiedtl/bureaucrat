// 8:8 fixed point

(use* std)
(use* varvara)

(struct Fxpt
	[int I8]
	[frc U8]
)

// Constants
(word ONE_SFT  (-- U16) [ 0x8000s ])  // (1 << FRAC_BITS*2)
(word FRC_MASK (-- U16) [ 0x00FFs ])  // (1 << FRAC_BITS) - 1
(word INT_LSFT (-- U8 ) [ 0x80 ])
(word INT_RSFT (-- U8 ) [ 0x08 ])

(word from-single (I8 -- Fxpt) [
	0 (wild (I8 U8 -- Fxpt) [])
])

(word from (I8 U8 -- Fxpt) [
	(let bases [U16 3] [ 1s 11s 111s ])
	swap dup signb move abs swap // save sign
	(as U16) dup
		dup 9s > (as U8) move
		99s > (as U8)
		(r move) +
		@bases : ->
	swap 0x10s * swap / 0x10s * 9s /
	move
	(as U16) INT_LSFT bsft
	(r move) +
	(r move) 0<> (when [ bnot 1+ ]) // restore sign
	(as Fxpt)
])

#(method Fxpt) (word abs (     Fxpt -- Fxpt) [ (as I16) abs   (as Fxpt) ])
#(method Fxpt) (word add (Fxpt Fxpt -- Fxpt) [ (as I16 I16) + (as Fxpt) ])
#(method Fxpt) (word sub (Fxpt Fxpt -- Fxpt) [ (as I16 I16) - (as Fxpt) ])

// Multiply by parts in order to not overflow
// Now if only uxn has 32-bit mul/div...
#private
(word intmul32 (U16 U16 U16 U16 -- U16) [
	(let int1 U16) (let frc1 U16) @frc1 <- @int1 <-
	(let int2 U16) (let frc2 U16) @frc2 <- @int2 <-

	$int1 $int2 * INT_LSFT bsft
	$int1 $frc2 * +
	$frc1 $int2 * +
	$frc1 $frc2 * INT_RSFT bsft FRC_MASK band +
])

//
// p = (ai*ai)<<frac_bits + ai*bf + af*bi + (af*bf)>>frac_bits&frac_bits
//
#(method Fxpt) (word mul (Fxpt Fxpt -- Fxpt) [
	2dup (as I16 I16) signb swap signb beor move

	move ;abs ;parts (as U16 U16)
	(r move) ;abs ;parts (as U16 U16)
	intmul32

	(r move) 0<> (when [ bnot 1+ ])
	(as Fxpt)
])

// Divide by multiplying by reciprocal. Does introduce precision loss...
// Also to prevent overflow -- if we want to divide directly we need to
// shift << 8, which would overflow
//
// q = dvd * (1/dvs)
//
#(method Fxpt) (word div (Fxpt Fxpt -- Fxpt) [
	(as I16 I16) 2dup signb swap signb beor move
	abs ONE_SFT swap /
	swap abs
	(as Fxpt Fxpt) ;mul 0x10 bsft (as Fxpt)
	(r move) 0<> (when [ bnot 1+ (as Fxpt) ])
	(as Fxpt)
])

// Wanna divide by int? Just do it directly, not shifting or reciprocal nonsense
// needed
// (Because the divisor isn't shifted left, the dividend doesn't need to be)
//
(word intdiv (Fxpt U8 -- Fxpt) [
	(as U16) (as I16 I16) / (as Fxpt)
])

// Get abs, print int portion, multiply/divide fraction, and then print that
//
#(method Fxpt) (word print (Fxpt -- ) [
	dup (as I16) neg? (when [ '- emit ;abs ] [ (as Fxpt) ])
	;parts
	swap print-dec '. emit
	10s * 0x10s / 10s * 0x10s /   // frac * 10 / 0x10 * 10 / 0x10
	print-dec
])

#(method Fxpt) (word parts (Fxpt -- I16 U16) [
	//(split I8 U8) move sext (r move) (as U16)
	dup FRC_MASK band move
	INT_RSFT bsft (as I8) sext
	(r move)
])

//
//              x^3     x^5     x^7
// sin x = x - ----- + ----- - ----- ...
//              !3      !5      !7
//
(word sin (Fxpt -- Fxpt) [
	(word pow2  (Fxpt -- Fxpt) [ dup ;mul ])
	(word pow3  (Fxpt -- Fxpt) [ dup over ;mul ;mul ])
	(word pow4  (Fxpt -- Fxpt) [ dup over ;mul over ;mul ;mul ])

	// x
	copy

	// - x^3/3!
	(r copy) pow3 6 intdiv -

	// + x^5/5! (x^4/5! * x)
	(r copy) pow4 120 intdiv
		(r copy) ;mul +

	// - x^7/7! (x^4/5! * x^3/42)
	(r copy) pow4 120 intdiv
		(r copy) pow3 42 intdiv ;mul -

	// + x^9/9! (x^4/5! * x^3/42 * x^2/72)
	(r copy) pow4 120 intdiv
		(r copy) pow2 42 intdiv ;mul
		(r copy) pow3 78 intdiv ;mul +

	(r drop)
])
