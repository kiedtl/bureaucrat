// 8:8 fixed point

(use* std)
(use* varvara)

(struct Fxpt
	[int I8]
	[frc U8]
)

(word from-single (I8 -- Fxpt) [
	0 (wild (I8 U8 -- Fxpt) [])
])

(word from (I8 U8 -- Fxpt) [
	(let bases [U16 3] [ 10s 100s 1000s ])
	(as U16)
	dup
		dup 9s > (as U8) move
		99s > (as U8)
		(r move) +
		@bases : ->
	swap 0x100s * swap /
	move
	0 (wild (I8 U8 -- I16) [])
	(r move) +
	(as Fxpt)
])

#(method Fxpt) (word add (Fxpt Fxpt -- Fxpt) [ (as I16 I16) + (as Fxpt) ])
#(method Fxpt) (word sub (Fxpt Fxpt -- Fxpt) [ (as I16 I16) - (as Fxpt) ])

// Multiply by parts in order to not overflow
// Now if only uxn has 32-bit mul/div...
//
// p = (ai*ai)<<frac_bits + ai*bf + af*bi + (af*bf)>>frac_bits&frac_bits
//
#(method Fxpt) (word mul (Fxpt Fxpt -- Fxpt) [
	2dup (as I16 I16) signb swap signb beor move

	(let int1 U16) (let frc1 U16)
		(split I8 U8) (as U16) @frc1 <- abs (as U16) @int1 <-
	(let int2 U16) (let frc2 U16)
		(split I8 U8) (as U16) @frc2 <- abs (as U16) @int2 <-

	$int1 $int2 * 0x80 bsft
	$int1 $frc2 * +
	$frc1 $int2 * +
	$frc1 $frc2 * 0x08 bsft 0xffs band +

	(r move) 0<> (when [ bnot 1+ ])
	(as Fxpt)
])

// Divide by multiplying by reciprocal. Does introduce precision loss...
// Also to prevent overflow -- if we want to divide directly we need to
// shift << 8, which would overflow
//
// q = dvd * (1/dvs)
//
#(method Fxpt) (word div (Fxpt Fxpt -- Fxpt) [
	(as I16 I16) 2dup signb swap signb beor move
	abs 0x8000s swap /
	swap abs
	(as Fxpt Fxpt) ;mul 0x10 bsft (as Fxpt)
	(r move) 0<> (when [ bnot 1+ (as Fxpt) ])
	(as Fxpt)
])

// Wanna divide by int? Just do it directly, not shifting or reciprocal nonsense
// needed
// (Because the divisor isn't shifted left, the dividend doesn't need to be)
//
(word intdiv (Fxpt I8 -- Fxpt) [
	sext (as I16 I16) / (as Fxpt)
])

// Basically * -1
// Could also subtract from zero I think
#(method Fxpt) (word negate (Fxpt -- Fxpt) [
	(split I8 U8) swap -1i * swap
	(wild (I8 U8 -- Fxpt) [])
])

// Get abs, print int portion, multiply/divide fraction (frac * 100 / 0x100),
// and then print that
#(method Fxpt) (word print (Fxpt -- ) [
	(as I16) dup neg? (when [ '- emit abs ] [ (as U16) ])
	(split I8 U8) swap print-dec '. emit
	(as U16) 100s * 0x100s / print-dec
])
