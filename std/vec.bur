(use* core)
(use std)
(use alloc)
(use* varvara)

(struct Vector (Any)
	[capacity U16]
	[len U16]
	[items @[$0]]
)

(word init ( @(AnyOf Vector) -- ) [
	0s swap init-sized
])

(word init-sized ( U16 @(AnyOf Vector) -- ) [
	2dup :capacity <-
	0s over :len <-
	swap
	# ( vec* capacity )
	(sizeof (Child (FieldType (Child $0) items))) (as U16) *
		alloc/get std/unwrap (as @(Of Vector $0))
	# ( vec* items* )
	swap :items <-
])

(word append ( (Child (FieldType (Child $0) items)) @(AnyOf Vector) -- ) [
	dup :len -> 1+ over :len <-
	dup :len -> over ensure-capacity
	dup :len -> 1-
		(sizeof (Child (FieldType (Child $0) items))) (as U16) *
	swap :items -> + <-
])

(word shrink-by ( U16 @(AnyOf Vector) -- ) [
	tuck
	:len -> swap - # TODO: check for overflow
	# ( vec* new-len )
	swap :len <-
])

(word ensure-capacity ( U16 @(AnyOf Vector) -- ) [
	2dup :capacity -> over < (when [
		swap
		2dup :capacity <-
		swap (sizeof (Child (FieldType (Child $0) items))) (as U16) *
		# ( new-len vec* computed-size )
		over :items -> (as @Opaque) alloc/reget
		std/unwrap (as $0)
		# ( new-len vec* item* )
		swap :items <-
		drop
	] [ 2drop drop ])
])

(word deinit ( @(AnyOf Vector) -- ) [
	:items -> alloc/de
])

(test Vector/init-sized [
	alloc/init

	(var v1 (Of Vector U8))
	20s @v1 init-sized
	@v1 :len -> (should eq 0s)
	@v1 :capacity -> (should eq 20s)
	@v1 deinit

	(var v2 (Of Vector U16))
	10s @v2 init-sized
	@v2 :capacity -> (should eq 10s)
	@v2 deinit
])

(test Vector/append [
	alloc/init
	(var lst (Of Vector U16))
	@lst init

	   0x8s @lst append
	   314s @lst append
	   0x7s @lst append
	  1002s @lst append
	 0x184s @lst append

	@lst :len -> (should eq 5s)
	8s @lst :items -> + -> (should eq 0x0184s)
	6s @lst :items -> + -> (should eq   1002s)
	4s @lst :items -> + -> (should eq    0x7s)
	2s @lst :items -> + -> (should eq    314s)
	0s @lst :items -> + -> (should eq    0x8s)
])

# It should shrink the len while retaining capacity.
(test Vector/shrink-by [
	alloc/init
	(var lst (Of Vector U16))
	@lst init

	1s @lst append
	2s @lst append
	3s @lst append
	4s @lst append

	2s @lst shrink-by

	@lst :len -> (should eq 2s)
	@lst :capacity -> (should eq 4s)
	0s @lst :items -> + -> (should eq 1s)
	2s @lst :items -> + -> (should eq 2s)
])
