#!/home/kiedtl/src/zf/new/zig-out/bin/zf
# vim: ts=4 sts=4 sw=4 expandtab

(mac stash    [ (asm nil .Ostash) ])
(mac grab     [ (asm 1 .Ostash) ])

(word dup     [ 0 (asm nil .Opick) ])
(word over    [ 1 (asm nil .Opick) ])
(word swap    [ 1 (asm nil .Oroll) ])
(word drop    [ 1 (asm nil .Odrop) ])
(word nip     [ swap drop ])

(word not     [ (asm nil .Onot) ])
(word /mod    [ (asm nil .Odmod) ])
(word *       [ (asm nil .Omul) ])
(word +       [ (asm nil .Oadd) ])
(word -       [ (asm nil .Osub) ])

(word /       [ /mod nip ])
(word mod     [ /mod drop ])

(word tuck    [ swap over ])

(word cmp     [ (asm nil .Ocmp) ])
(word =       [ cmp not ])
(word <       [ cmp -1 = ])
(word >       [ cmp 1 = ])
(word <>      [ = not ])
(word 0=      [ 0 = ])
(word T=      [ T = ])             # FIXME: cmp cannot compare non-numerical value!
(word T<>     [ T <> ])
(word nil?    [ nil = ])

(word do      [ stash (asm nil .Osr) ])
(word ?do     [ swap (cond [ T= ] [ do ] [ drop ]) ])
(word dip     [ swap stash do grab ])
(word sip     [ stash dup grab swap [ do ] dip ])
(word bi      [ [ sip ] dip do ])
(word bi*     [ [ dip ] dip do ])
(word bi@     [ dup bi* ])

(word square  [ dup * ])

(word gcd [
    (until [ 0= ]
        [ tuck mod ]
    )
    drop
])

(word hypot [
    [ square ] bi@ + sqrt
])

# if (n < 2) return n
# return fib(n - 1) + fib(n - 2)
#(word bad-fib [
#    $n<-
#    (cond
#        [ $n->> 2 < ] [ $n-> ]
#        [
#            $n->> 1 - bad-fib
#            $n->  2 - bad-fib +
#        ]
#    )
#])

#54 45 gcd
#324324 12463 gcd
3 4 hypot
print-stack

#40 bad-fib

#print-stack

# todo: -|, +|, *|, -%, +%, *%

# "An 'and' expression" [
#     [
#         0 (and 0 nil) .should-be
#     ] "return the first arg if it is false." $it->> .should
# ] test
