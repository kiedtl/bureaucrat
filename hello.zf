(device System 0x00
	[_unused   U16]
	[expansion U16] # (Ptr16 ExpansionCmd)
	[wst        U8]
	[rst        U8]
	[metadata  U16] # (Ptr16 Metadata)
	[red       U16]
	[green     U16]
	[blue      U16]
	[debug      U8]
	[state      U8]
)

(device Console 0x10
	[vector U16] #[vector (Fn u8 --)]
	[read U8]
	[exec U8]          # ? (not documented)
	[mode U8]          # ? (not documented)
	[dead U8]          # ? (not documented)
	[exit U8]          # ? (not documented)
	[type U8] #[type ConsoleType] # enum
	[write U8]         # ? (not documented)
	[error U8]         # ? (not documented)
)

(word 2dup ( (AnySz $0) Any -- $0 $1 $0 $1) [ over over ])

(word lda  (       AnyPtr16 -- (Child $0)   ) [ (asm "g" .Op/Olda)       ])
(word ldak (       AnyPtr16 -- $0 (Child $0)) [ (asm "kg" .Op/Olda)      ])
(word sta  (   Any AnyPtr16 --              ) [ (asm "g" .Op/Osta)       ])

(word deo   (    Any AnyDev --              ) [ (asm "g" .Op/Odeo)       ])
(word dbg   (               --              ) [ 0x0 .System/debug deo    ])
(word emit  (          Any8 --              ) [ .Console/write deo       ])
(word nl    (               --              ) [ 0x0a emit                ])

(word nip   ((AnySz $0) Any -- $0           ) [ (asm "g" .Op/Onip)       ])
(word dup   (           Any -- $0 $0        ) [ (asm "g" .Op/Odup)       ])
(word swap  ((AnySz $0) Any -- $0 $1        ) [ (asm "g" .Op/Oswp)       ])
(word drop  (           Any --              ) [ (asm "g" .Op/Odrop)      ])
(word over  ((AnySz $0) Any -- $1 $0 $1     ) [ (asm "g" .Op/Oovr)       ])

# TODO
#(word rot   (Any Any Any -- $2 $1 $0    ) [ (asm "g" .Op/Orot)      ])
#(word rot>  (Any Any Any -- $1 $2 $0    ) [ rot rot                 ])

(word rot   ((AnySz $0) (AnySz $0) Any -- $2 $1 $0) [ (asm "g" .Op/Orot)      ])
(word rot>  (    $0  $0 Any -- $0 $0 $0     ) [ rot rot                 ])
(word tuck  (       Any Any -- $0 $1 $0     ) [ swap over               ])
(word tuck> (       Any Any -- $1 $1 $0     ) [ over swap               ])

(word =     (       $0  Any -- Bool         ) [ (asm "g" .Op/Oeq)       ])
(word <>    (       $0  Any -- Bool         ) [ (asm "g" .Op/Oneq)      ])
(word nil?  (          Bool -- Bool         ) [ nil =                   ])
(word T?    (          Bool -- Bool         ) [ T =                     ])
(word <     ((AnySz $0) Any -- Bool         ) [ (asm "g" .Op/Olt)       ])
(word >     ((AnySz $0) Any -- Bool         ) [ (asm "g" .Op/Ogt)       ])
(word +     ((AnySz $0) Any -- $0           ) [ (asm "g" .Op/Oadd)      ])
(word 1+    (           Any -- $0           ) [ (asm "g" .Op/Oinc)      ])
(word -     ((AnySz $0) Any -- $0           ) [ (asm "g" .Op/Osub)      ])
(word /     ((AnySz $0) Any -- $0           ) [ (asm "g" .Op/Odiv)      ])
(word mod   ((AnySz $0) Any -- $0           ) [ 2dup / * -              ])
(word /mod  ((AnySz $0) Any -- $0 $0        ) [ 2dup / rot> mod         ])
(word *     ((AnySz $0) Any -- $0           ) [ (asm "g" .Op/Omul)      ])
(word 0=    (           Any -- Bool         ) [ 0 (as $0) =             ])
(word 0<>   (           Any -- Bool         ) [ 0 (as $0) <>            ])
(word 0<    (           Any -- Bool         ) [ 0 (as $0) <             ])
(word 0>    (           Any -- Bool         ) [ 0 (as $0) >             ])

# TODO: this is stupid... needs to be optimized
# (Probably bake or/and into language to ensure short-circuiting)
(word not   (          Bool -- Bool         ) [ (when [ nil ] [ t ])    ])
(word or    (     Bool Bool -- Bool         ) [ (when [ drop t ]) ])
(word and   (     Bool Bool -- Bool) [ (when [ (when [t] [ nil ]) ] [ drop nil ]) ])

(word print8 (U8 --) [
	dup 0= (when [ drop '0 emit return ])

	0x99 swap # stop indicator
	
	(until [ 0= ] [
		16 /mod
		dup 9 > (when [ 10 - 'a + ] [ '0 + ])
		swap
	])
# TODO: drop null byte?
	(until [ 0x99 = ] [ emit ])

	drop # drop stop indicator
])

(word print16 (U16 --) [
	dup 0= (when [ drop '0 emit return ])

	0x99s swap # stop indicator
	
	(wild (U16 U16 -- U16) [
		(until [ 0= ] [
			16s /mod
			dup 9s > (when [ 10s - 'as + ] [ '0s + ])
			swap
		])

		(until [ 0x99s = ] [ (as U8) emit ])
	])

	drop # drop stop indicator
])

(word print-base (Any (AnySz $1) --) [
	(local base $0 1)
	@base <-

	dup 0= (when [ drop '0 emit return ])

	0x99 (as $0) swap # stop indicator

	(wild ($0 $0 -- $0) [
		(until [ 0= ] [
			$base (as $0) /mod
			dup 9 (as $0) > (when
				[ 10 (as $0) - 'a (as $0) + ]
				[ '0 (as $0) + ]
			)
			swap
		])

		(until [ 0x99 (as $0) = ] [ (as U8) emit ])
	])

	drop # drop stop indicator
])

(word print (Any --) [
	16 (as $0) print-base
])

(word print-dec (Any --) [
	10 (as $0) print-base
])

#0xbeefs print nl
#0x3b    print nl
#0x0d    print
#0xef    print
#0xaceds print
#0xcafes print nl

(word print-string ((Ptr16 U8) -- ) [ ldak (while [ 0<> ] [ emit 1+ ldak ]) drop drop ])

#(word foobar (Any -- $0) [
#	(local baz $0 1)
#	1+ @baz sta
#	$baz
#])

#0 foobar foobar foobar print nl
#0s foobar foobar foobar foobar print nl

#(word variable (Any -- (Ptr16 $0)) [
#	(local _S $0 1)
#	drop
#	@_S
#])
#
#0s variable dbg drop
#0  variable dbg drop
#nl

#(struct Foo
#	[bar U16]
#	[baz U8]
#)

#(local foo Foo 0)

#@foo :bar
#@foo :baz
#dbg

#0xffffs @foo :bar sta
#     9  @foo :baz sta
#        @foo :bar lda print nl

(struct ChunkHeader
	[prev (Ptr16 ChunkHeader)]
	[next (Ptr16 ChunkHeader)]
	[free Bool]
)

(word <- ((Child $0) AnyPtr16 -- ) [ sta ])
(word -> (AnyPtr16 -- (Child $0)) [ lda ])

(word first  (-- (Ptr16 ChunkHeader)) [ here (as (Ptr16 ChunkHeader)) ])

(word over-sb (Any16 Any8 -- $1 $0 $1) [
	(wild ($1 $0 -- $1 $0 $1) [
		"TODO: over-sb" print-string nl
	])
])

(word swap-sb (Any16 Any8 -- $0 $1) [
	(wild ($1 $0 -- $0 $1) [
		(asm "" .Op/Orot)
		(asm "" .Op/Orot)
	])
])

(word alloc-init ( -- ) [
	0s (as (Ptr16 ChunkHeader))
		first :prev <-
	0xFFFFs (as (Ptr16 ChunkHeader))
		first :next <-
	T
		first :free <-
])

# ( bytes -- *ptr )
(word alloc ( U16 -- (Ptr16 U8) ) [
	(local size U16 1)
	@size <-

	"*** Allocating " print-string
	$size             print-dec
	" bytes\n"        print-string

	first
	(while [
		#dup "Sz: " print-string chunk-size print-dec nl
		#    "Rq: " print-string $size print-dec nl
		#dup "Nx: " print-string :next -> print nl
		#dup "Av: " print-string :free -> print-bool nl
		#nl

		dup :free -> not
		swap-sb chunk-size $size <
		or
	] [
		"    Skipping " print-string dup print nl

		dup :next -> 0= (when [ "Out of memory\n" print-string 0s return ])
		    :next ->
	])

	"Chosen: " print-string dup print nl nl

	(local chosen (Ptr16 ChunkHeader) 1)
	@chosen <-


	nil $chosen :free <-

	$chosen :next -> $chosen - $size - 5s < not (when [
		(local next (Ptr16 ChunkHeader) 1)
		5s $size $chosen + + @next <-

		$chosen          $next   :prev <-
		$chosen :next -> $next   :next <-
		T                $next   :free <-
		$next            $chosen :next -> :prev <-
		$next            $chosen :next <-
	])

	$chosen
])

(word chunk-size ((Ptr16 ChunkHeader) -- U16) [
	dup :next -> swap -
	(sizeof ChunkHeader) (as U16) -
])

(word print-bool (Bool -- ) [ (when [ "T" ] [ "nil" ]) print-string ])

(word alloc-print-chunk ((Ptr16 ChunkHeader) -- ) [
	"Chunk: " print-string
		dup print
	" \t" print-string
	dup :free -> print-bool "\t" print-string
	"Prev: " print-string
		dup :prev -> print
	" \t" print-string
	"Next: " print-string
		dup :next -> print
	" \t" print-string
	"Size: " print-string
		dup chunk-size print-dec
	nl
	drop
])

(word alloc-print-chunks (--) [
	first
	(while [ :next -> 0<> ] [
		dup alloc-print-chunk
		:next ->
	])
])

alloc-init

10s  alloc drop
107s alloc drop
2s   alloc drop
34s  alloc drop

nl

alloc-print-chunks

#(struct Box (Any) [value $0])

#(word box (Any -- (Ptr16 (Of Box $0))) [
#	(local retval (Of Box $0) 1)
#	@retval :value sta
#	@retval
#])

#(word unbox ((Ptr16 (AnyOf Box)) -- (FieldType (Child $0) value)) [
#	:value lda
#])

#0xffffs box
#0x02    box

#unbox print nl
#unbox print nl

# TODO: unit tests

#0xffabs 0xba swap-sb print nl print nl
#t   nil or  print-bool nl
#nil t   or  print-bool nl
#t   t   or  print-bool nl
#nil nil or  print-bool nl
#t   nil and print-bool nl
#nil t   and print-bool nl
#t   t   and print-bool nl
#nil nil and print-bool nl
