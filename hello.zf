(use* prelude)

(test lang_decl_scoping [
	(word foobar [ 1 ])
	(word baz [
		(word foobar [ 2 ])
		foobar
	])
	foobar (should eq 1)
	baz    (should eq 2)
])

(test lang_stack_structs [
	(struct A [ foo U8 ])
	(struct B [ foo U16 ])
	(struct C [ foo U8 ] [ bar U8 ])

	0x24 (make A) :foo (should eq 0x24)

	1 2 3 0x24s (make B) drop (should eq 3)
	drop drop

	1 2 3 4 (make C) drop (should eq 2) (should eq 1)
	3 4 (make C) :foo (should eq 4)
	3 4 (make C) :bar (should eq 3)

	1 2 (make C) 3 4 (make C) swap :foo (should eq 2)
])

(device System 0x00
	[_unused   U16]
	[expansion U16] # (Ptr16 ExpansionCmd)
	[wst        U8]
	[rst        U8]
	[metadata  U16] # (Ptr16 Metadata)
	[red       U16]
	[green     U16]
	[blue      U16]
	[debug      U8]
	[state      U8]
)

(device Console 0x10
	[vector U16] #[vector (Fn u8 --)]
	[read U8]
	[exec U8]          # ? (not documented)
	[mode U8]          # ? (not documented)
	[dead U8]          # ? (not documented)
	[exit U8]          # ? (not documented)
	[type U8] #[type ConsoleType] # enum
	[write U8]         # ? (not documented)
	[error U8]         # ? (not documented)
)

(word dei   (        AnyDev -- (USz $0)     ) [ (asm "g" .Op/Odei)       ])
(word deo   ((AnySz $0) AnyDev --           ) [ (asm "g" .Op/Odeo)       ])
(word dbg   (               --              ) [ 0x1 .System/debug deo    ])
(word emit  (          Any8 --              ) [ .Console/write deo       ])
(word nl    (               --              ) [ 0x0a emit                ])

(word print8 (U8 --) [
	dup 0= (when [ drop '0 emit return ])

	0x99 swap # stop indicator
	
	(until [ 0= ] [
		16 /mod
		dup 9 > (when [ 10 - 'a + ] [ '0 + ])
		swap
	])
# TODO: drop null byte?
	(until [ 0x99 = ] [ emit ])

	drop # drop stop indicator
])

(word print16 (U16 --) [
	dup 0= (when [ drop '0 emit return ])

	0x99s swap # stop indicator
	
	(wild (U16 U16 -- U16) [
		(until [ 0= ] [
			16s /mod
			dup 9s > (when [ 10s - 'as + ] [ '0s + ])
			swap
		])

		(until [ 0x99s = ] [ (as U8) emit ])
	])

	drop # drop stop indicator
])

(word print-base (Any U8 --) [
	(local base U8 1)
	@base <-

	#dup 0= (when [ drop '0 emit return ])

	0x99 (as $1) swap # stop indicator

	(wild ($1 $1 -- $1) [
		(until [ 0= ] [
			$base (as $1) /mod
			dup 9 (as $1) > (when
				[ 10 (as $1) - 'a (as $1) + ]
				[ '0 (as $1) + ]
			)
			swap
		])

		(until [ 0x99 (as $1) = ] [ (as U8) emit ])
	])

	drop # drop stop indicator
])

(word print (Any --) [ 16 print-base ])
(word print-dec (Any --) [ 10 print-base ])

(struct Maybe0 (Any) [value $0])

(word unwrap ((AnyOf Maybe0) -- (FieldType $0 value)) [
	:value
	dup 0= (when [ "Unwrapped 0 value" panic ])
])

(word orelse ((AnyOf Maybe0) (FieldType $1 value) -- (FieldType $1 value)) [
	swap :value dup 0= (when [ drop ] [ nip ])
])
(test orelse [ 0 (make (Of Maybe0 U8)) 12 orelse (should eq 12) ])

(word panic ((Ptr16 U8) -- ) [
	"Panic: " print-string print-string nl
	.System/rst (asm "" .Op/Odei) 2 /
	(while [ 0> ] [
		"  at " print-string
		(asm "sr" .Op/Osth) print nl
		1-
	])
	"Aborting.\n" print-string
	(asm "" .Op/Ohalt)
])

(word print-string ((Ptr16 U8) -- ) [ ldak (while [ 0<> ] [ emit 1+ ldak ]) drop drop ])

# I wanted to have U16 guards, that way we could have 0x1cedc0fe
#
# Sadly that blows up the size to 9 bytes, so we have to settle with
# just lukewarm 0xc0fe
#
(struct ChunkHeader
	[guard1 U8]
	[prev (Ptr16 ChunkHeader)]
	[next (Ptr16 ChunkHeader)]
	[free Bool]
	[guard2 U8]
)

(word <- ((Child $0) AnyPtr16 -- ) [ sta ])
(word -> (AnyPtr16 -- (Child $0)) [ lda ])

(word first  (-- (Ptr16 ChunkHeader)) [ here (as (Ptr16 ChunkHeader)) ])

(word alloc-init ( -- ) [
	0s (as (Ptr16 ChunkHeader))
		first :prev <-
	0xFFFFs (as (Ptr16 ChunkHeader))
		first :next <-
	T
		first :free <-
	0xc0    first :guard1 <-
	0xfe    first :guard2 <-
])

# ( bytes -- *ptr )
(word alloc ( U16 -- (Of Maybe0 (Ptr16 U8))) [
	(local size U16 1)
	@size <-

	"*** Allocating " print-string
	$size             print-dec
	" bytes\n"        print-string

	first
	(while [
		#dup "Sz: " print-string chunk-size print-dec nl
		#    "Rq: " print-string $size print-dec nl
		#dup "Nx: " print-string :next -> print nl
		#dup "Av: " print-string :free -> print-bool nl
		#nl

		dup :free -> not
		swap-sb chunk-size $size <
		or
	] [
		"    Skipping " print-string dup print nl

		dup :next -> 0= (when [
			0s (as (Ptr16 U8)) (make (Of Maybe0 (Ptr16 U8)))
			return
		])
		    :next ->
	])

	"Chosen: " print-string dup print nl nl

	(local chosen (Ptr16 ChunkHeader) 1)
	@chosen <-


	nil $chosen :free <-

	$chosen chunk-size $size -
		(sizeof ChunkHeader) (as U16) 1+
	< not (when [
		(local next (Ptr16 ChunkHeader) 1)
		(sizeof ChunkHeader) (as U16) $size $chosen + + @next <-

		$chosen          $next   :prev <-
		$chosen :next -> $next   :next <-
		T                $next   :free <-
		$next            $chosen :next -> :prev <-
		$next            $chosen :next <-
		0xc0             $chosen :guard1 <-
		0xfe             $chosen :guard2 <-
	])

	$chosen (sizeof ChunkHeader) (as (Ptr16 U8)) +
	(make (Of Maybe0 (Ptr16 U8)))
])

(word dealloc (AnyPtr16 -- ) [
	(sizeof ChunkHeader) (as U16) -
	(as (Ptr16 ChunkHeader))
	#"Dealloc'ing: " print-string dup print nl

		dup     :guard1 -> 0xc0 <>
		over-sb :guard2 -> 0xfe <>
	or (when [ "Bad ptr\n" print-string return ])

	T swap-sb :free <-
])

(word chunk-size ((Ptr16 ChunkHeader) -- U16) [
	dup :next -> swap -
	(sizeof ChunkHeader) (as U16) -
])

(word alloc-defrag (--) [
	first
	(until [ :next -> 0= ] [
		dup     :free ->
		over-sb :next -> :free -> and
		(when [
			dup :next ->

			# current->next = next->next
			# ( current next )
			over :next
				# ( current next @current->next )
				over :next -> swap <-

			dup :next -> 0<> (when [
				# ( current next )
				:next ->
					# ( current $next->next )
					:prev
					# ( current $next->next->prev )
					over swap <-
					# ( current )

			] [ drop ])
		] [ :next -> ])
	])
])

(word print-bool (Bool -- ) [ (when [ "T" ] [ "nil" ]) print-string ])

(word alloc-print-chunk ((Ptr16 ChunkHeader) -- ) [
	dup print " \t" print-string
	dup :free -> print-bool "\t" print-string
	dup :prev -> print " \t" print-string
	dup :next -> print " \t" print-string
	dup chunk-size print-dec
	nl
	drop
])

(word alloc-print-chunks (--) [
	"Chunk\tFree\tPrev\tNext\tSize\n" print-string

	first
	(while [ :next -> 0<> ] [
		dup alloc-print-chunk
		:next ->
	])

	nl
])

# ( val len ptr -- )
(word memset8 (Any8 U16 AnyPtr16 -- ) [
	(as (Ptr16 U8))
	dup rot + (as (Ptr16 U8))

	(while [ drop 2dup <> ] [
		# ( val ptr end )
		rot-bss>                  # ( end val  ptr  )
		stak                      # ( end val  ptr  )
		(sizeof $0) (as U16) +    # ( end val  ptr+ )
		rot-sbs                   # ( val ptr+ end  )
	])
])

(word main [
	#0xbeefs print nl
	#0x3b    print nl
	#0x0d    print
	#0xef    print
	#0xaceds print
	#0xcafes print nl
	
	#(word foobar (Any -- $0) [
	#	(local baz $0 1)
	#	1+ @baz sta
	#	$baz
	#])
	
	#0 foobar foobar foobar print nl
	#0s foobar foobar foobar foobar print nl
	
	#(word variable (Any -- (Ptr16 $0)) [
	#	(local _S $0 1)
	#	drop
	#	@_S
	#])
	#
	#0s variable dbg drop
	#0  variable dbg drop
	#nl
	
	#(struct Foo
	#	[bar U16]
	#	[baz U8]
	#)
	
	#(local foo Foo 0)
	
	#@foo :bar
	#@foo :baz
	#dbg
	
	#0xffffs @foo :bar sta
	#     9  @foo :baz sta
	#        @foo :bar lda print nl
	
	0xAA
		here 0xffffs -
	here memset8
	
	(asm "k" .Op/Odrop)

	alloc-init
	
	(local ptrs (Ptr16 U8) 4)
	107s alloc unwrap drop
	107s alloc unwrap 0s @ptrs + <-
	10s  alloc unwrap 2s @ptrs + <-
	26s  alloc unwrap 4s @ptrs + <-
	2s   alloc unwrap drop
	#34s  alloc unwrap dealloc
	30s  alloc unwrap drop
	30s  alloc unwrap 6s @ptrs + <-
	
	0s @ptrs + -> dealloc
	2s @ptrs + -> dealloc
	4s @ptrs + -> dealloc
	6s @ptrs + -> dealloc
	
	nl
	
	alloc-print-chunks
	alloc-defrag
	alloc-print-chunks
	
	#(struct Box (Any) [value $0])
	
	#(word box (Any -- (Ptr16 (Of Box $0))) [
	#	(local retval (Of Box $0) 1)
	#	@retval :value sta
	#	@retval
	#])
	
	#(word unbox ((Ptr16 (AnyOf Box)) -- (FieldType (Child $0) value)) [
	#	:value lda
	#])
	
	#0xffffs box
	#0x02    box
	
	#unbox print nl
	#unbox print nl
])
