(word 2dup ( (AnySz $0) Any -- $0 $1 $0 $1) [ over over ])

(word lda  (       AnyPtr16 -- (Child $0)   ) [ (asm "g" .Op/Olda)       ])
(word ldak (       AnyPtr16 -- $0 (Child $0)) [ (asm "kg" .Op/Olda)      ])
(word sta  (   Any AnyPtr16 --              ) [ (asm "g" .Op/Osta)       ])
(word stak (   Any AnyPtr16 -- $1 $0        ) [ (asm "kg" .Op/Osta)      ])

(word nip   ((AnySz $0) Any -- $0           ) [ (asm "g" .Op/Onip)       ])
(word dup   (           Any -- $0 $0        ) [ (asm "g" .Op/Odup)       ])
(word swap  ((AnySz $0) Any -- $0 $1        ) [ (asm "g" .Op/Oswp)       ])
(word drop  (           Any --              ) [ (asm "g" .Op/Odrop)      ])
(word over  ((AnySz $0) Any -- $1 $0 $1     ) [ (asm "g" .Op/Oovr)       ])

# TODO
#(word rot   (Any Any Any -- $1 $0 $2    ) [ (asm "g" .Op/Orot)      ])
#(word rot>  (Any Any Any -- $0 $2 $1    ) [ rot rot                 ])

(word rot   ((AnySz $0) (AnySz $0) Any -- $1 $0 $2) [ (asm "g" .Op/Orot)      ])
(word rot>  (    $0  $0 Any -- $0 $0 $0     ) [ rot rot                  ])
(word tuck  (       Any Any -- $0 $1 $0     ) [ swap over                ])
(word tuck> (       Any Any -- $1 $1 $0     ) [ over swap                ])

(word =     ((AnySz $0) Any -- Bool         ) [ (asm "g" .Op/Oeq)        ])
(word <>    ((AnySz $0) Any -- Bool         ) [ (asm "g" .Op/Oneq)       ])
(word nil?  (          Bool -- Bool         ) [ nil =                    ])
(word T?    (          Bool -- Bool         ) [ T =                      ])
(word <     ((AnySz $0) Any -- Bool         ) [ (asm "g" .Op/Olt)        ])
(word >     ((AnySz $0) Any -- Bool         ) [ (asm "g" .Op/Ogt)        ])
(word +     ((AnySz $0) Any -- $0           ) [ (asm "g" .Op/Oadd)       ])
(word 1+    (           Any -- $0           ) [ (asm "g" .Op/Oinc)       ])
(word 1-    (           Any -- $0           ) [ 1 -                      ])
(word -     ((AnySz $0) Any -- $0           ) [ (asm "g" .Op/Osub)       ])
(word /     ((AnySz $0) Any -- $0           ) [ (asm "g" .Op/Odiv)       ])
(word mod   ((AnySz $0) Any -- $0           ) [ 2dup / * -               ])
(word /mod  ((AnySz $0) Any -- $0 $0        ) [ 2dup / rot> mod          ])
(word *     ((AnySz $0) Any -- $0           ) [ (asm "g" .Op/Omul)       ])
(word 0=    (           Any -- Bool         ) [ 0 (as $0) =              ])
(word 0<>   (           Any -- Bool         ) [ 0 (as $0) <>             ])
(word 0<    (           Any -- Bool         ) [ 0 (as $0) <              ])
(word 0>    (           Any -- Bool         ) [ 0 (as $0) >              ])

# TODO: this is stupid... needs to be optimized
# (Probably bake or/and into language to ensure short-circuiting)
(word not   (          Bool -- Bool         ) [ (when [ nil ] [ t ])    ])
(word or    (     Bool Bool -- Bool         ) [ (when [ drop t ]) ])
(word and   (     Bool Bool -- Bool) [ (when [ (when [t] [ nil ]) ] [ drop nil ]) ])

(test or_basic [
	t   nil or (should eq T)
	nil t   or (should eq T)
	t   t   or (should eq T)
	nil nil or (should eq nil)
])

(test and_basic [
	t   nil and (should eq nil)
	nil t   and (should eq nil)
	t   t   and (should eq T)
	nil nil and (should eq nil)
])

(word rot-sbs (Any16 Any8 Any16 -- $1 $0 $2) [
	# sa0 sa1 bt sb0 sb1
	(wild ($2 $1 $0 -- $1 $0 $2) [
		(asm "s" .Op/Osth)  # sa0 sa1 bt | sb0 sb1
		(asm "" .Op/Orot)   # sa1 bt sa0 | sb0 sb1
		(asm "" .Op/Orot)   # bt sa0 sa1 | sb0 sb1
		(asm "rs" .Op/Osth) # bt sb0 sb1 sa0 sa1 
		(asm "s" .Op/Oswp)  # bt sa0 sa1 sb0 sb1 
	])
])

(word rot-bss (Any8 Any16 Any16 -- $1 $0 $2) [
	# bt sa0 sa1 sb0 sb1
	(wild ($2 $1 $0 -- $1 $0 $2) [
		(asm "s" .Op/Osth)  # bt sa0 sa1 | sb0 sb1
		(asm "" .Op/Orot)   # sa0 sa1 bt | sb0 sb1
		(asm "rs" .Op/Osth) # sa0 sa1 bt sb0 sb1
		(asm "" .Op/Orot)   # sa0 sa1 sb0 sb1 bt
	])
])

(word rot-bss> (Any8 Any16 Any16 -- $0 $2 $1) [
	# bt sa0 sa1 sb0 sb1
	(wild ($2 $1 $0 -- $0 $2 $1) [
		(asm "s" .Op/Oswp)  # bt sb0 sb1 sa0 sa1
		(asm "s" .Op/Osth)  # bt sb0 sb1 | sa0 sa1
		(asm "" .Op/Orot)   # sb0 sb1 bt | sa0 sa1
		(asm "rs" .Op/Osth) # sb0 sb1 bt sa0 sa1
	])
])

(test rot-sbs  [ 2s 1 0s rot-sbs  (should eq 2s) (should eq 0s) (should eq 1)   ])
(test rot-bss  [ 2 1s 0s rot-bss  (should eq 2)  (should eq 0s) (should eq 1s)  ])
(test rot-bss> [ 2 1s 0s rot-bss> (should eq 1s) (should eq 2)  (should eq 0s)  ])

(word over-sb (Any16 Any8 -- $1 $0 $1) [
	(wild ($1 $0 -- $1 $0 $1) [
		0
		(asm "s" .Op/Oovr)
		(asm "" .Op/Orot)
		(asm "" .Op/Odrop)
	])
])

(test over-sb  [ 999s 7 over-sb (should eq 999s) (should eq 7) (should eq 999s) ])

(word swap-sb (Any16 Any8 -- $0 $1) [
	(wild ($1 $0 -- $0 $1) [
		(asm "" .Op/Orot)
		(asm "" .Op/Orot)
	])
])

(test swap-sb  [ 0xffabs 0xba swap-sb (should eq 0xffabs) (should eq 0xba)      ])
