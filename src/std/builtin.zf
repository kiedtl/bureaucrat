1 !TRUE
0 !FALSE

word over  :  ( abc -- bca )  1 pick ;;
word 2drop :  (  ab -- b   )  drop drop ;;
word dup   :  ( abc -- bca )  0 pick ;;
word ?dup  :  ( abc -- bca )  dup if : dup ;; ;;
word 2dup  :  ( abc -- bca )  over over ;;
word swap  :  ( abc -- bca )  1 roll ;;
word rot   :  ( abc -- bca )  2 roll ;;
word rot>  :  ( abc -- cab )  rot rot ;;
word tuck  :  (  ab -- bab )  swap over ;;
word nip   :  (  ab -- b   )  swap drop ;;

word do-cond : <aqq-> ( f qT qF -- * )
	push over push   (f qT)  ((qF f))
	?do              ()
	pop pop          (f qF)  (())
	swap not swap    (x qF)
	?do
;;

word do    :  (   q --     )  @TRUE swap ?do ;;
word dip   :  (  vq -- v   )  swap push do pop ;;
word ?dip  :  (  vq -- v   )  push dup not ?ret pop dip ;;
word sip   :  (  vq -- v   )  push dup pop swap [ do ] dip ;;
word bi    :  ( xqq --     )  [ sip ] dip do ;;
word bi*   :  (xyqq --     )  [ dip ] dip do ;;
word bi@   :  ( xyq --     )  dup bi* ;;

word =     :  (  ab -- c   )  cmp not ;;
word <>    :  (  ab -- c   )  = not ;;
word <     :  (  ab -- c   )  cmp -1 = ;;
word >     :  (  ab -- c   )  cmp 1 = ;;
word <=    :  (  ab -- c   )  > not ;;
word >=    :  (  ab -- c   )  < not ;;
word 0=    :  (   a -- c   )  0 = ;;
word 0<>   :  (   a -- c   )  0 <> ;;
word 0<    :  (   a -- c   )  0 < ;;
word 0>    :  (   a -- c   )  0 > ;;
word 0>=   :  (   a -- c   )  0 >= ;;
word 0<=   :  (   a -- c   )  0 <= ;;
word ><    :  ( nlh -- c   )  2 pick >  rot> >  and ;;
word =><=  :  ( nlh -- c   )  2 pick >= rot> >= and ;;

word 1+    :  (   a -- c   )  1 + ;;
word 1-    :  (   a -- c   )  1 - ;;
word 2+    :  (   a -- c   )  2 + ;;
word 2-    :  (   a -- c   )  2 - ;;

word do-until : <q-*>
	[ dup dip swap ?ret again ] do
	drop
;;
word do-times : <nq-*>
	swap
	[ dup 0= ?ret
		1- push
		dup push do
		pop pop
		again
	] do
	2drop
;;

word /      :  (  ab -- c   )  /mod swap drop ;;
word mod    :  (  ab -- d   )  /mod drop ;;
word fact   :  (   n -- n   )  dup 1 <= ?ret dup 1- fact * ;;
word even?  :  (   n -- f   )  2 mod 0= ;;
word odd?   :  (   n -- f   )  even? not ;;
word int    :  (   f -- n   )  0 bxor ;;
word negate :  (  ab -- d   )  -1  * ;;
word abs    :  (   a -- c   )  dup 0< if : negate ;; ;;
word square :  (  ab -- d   )  dup * ;;
word min    :  (  am -- c   )  2dup < if : nip ;; orelse : drop ;; ;;
word max    :  (  aM -- c   )  2dup > if : nip ;; orelse : drop ;; ;;
word clamp  :  ( amM -- c   )  2 pick swap max swap min swap drop ;;
word gcd    :  (  ab -- n   )  until : tuck mod dup 0= ;; drop ;;

word reset  :  ( xya --     )  until : drop depth 0=  ;; ;;

word rev : <n-*> (...n -- ... )
	1 until :
		swap push dup push
		roll
		pop pop swap
		1+ 2dup =
	;;
	2drop
;;

(               ⎛           ⎞
                ⎜    |a|    ⎟
   lcm(a, b) =  ⎜ ───────── ⎟ × |b|
                ⎜ gcd(a, b) ⎟
                ⎝           ⎠
)
word lcm : <nn-> ( ab -- n )
	2dup           (abab)
	gcd            (abg)
	rot abs swap   (bag)
	/ swap abs *
;;

word pow   :  (  bp -- n   )  1 swap [ over * ] do-times nip ;;

( TODO )
word sqrt : <n-n>
	1
	[
		2dup / over - 2 /

		\ TODO: intead of comparing with 0, compare for equality with
		\ the previous iteration's value. This is to prevent infinite
		\ loops on inputs such as 232.
		dup 0= ?ret

		+
		again
	] do
	drop nip
;;

\ this uses the machin formula
\ pi = (4 * arctangent(1/5) - arctangent(1/239)) * 4
word pi     : (     -- n   )  4 1 5 / atan * 1 239 / atan - 4 * ;;

\
\         inf
\         ___  1
\ e = 1 + \   ───
\         /__ +n!
\         n=0
\
18 !E_ITERS
word e_iter : <nn-nn> ( iters accm -- )
	until :
		swap 1- swap over
		fact 1
		swap / + over
		1 =
	;;
;;
word e      : (     -- n   ) @E_ITERS 0 e_iter nip 1 + ;;

pi !PI
e  !E

word spc    : (     --     )  32 emit ;;
word cr     : (     --     )  10 emit ;;

10 !BASE
word decimal : 10 !BASE ;;
word hex     : 16 !BASE ;;

word .n : <n->
	dup 0< if :
		$- emit -1 *
	;;

	?dup 0= if :
		$0 emit
	;; orelse :
		999 swap (stop indicator)

		until :
			@BASE /mod   (r q)
			int swap int (q r)

			dup 9 > if :
				10 - $a +
			;; orelse :
				$0 +
			;;
			swap ?dup not
		;;

		until : emit dup 999 = ;;

		drop    (drop stop indicator)
	;;
;;

3735928559 !_RAND
word rand : <n->
	@_RAND 11109 * 13849 +
	524287 and 1 bshr
	dup !_RAND
;;
