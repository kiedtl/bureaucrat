1 !TRUE
0 !FALSE

: cond (fqq-)
	!_a !_b !_f
	@_f not @_a if
	@_f @_b if
;

: over     ( abc -- bca )  1 pick ;
: 2drop    (  ab -- b   )  drop drop ;
: dup      ( abc -- bca )  0 pick ;
: ?dup     ( abc -- bca )  dup [dup] if ;
: 2dup     ( abc -- bca )  over over ;
: swap     ( abc -- bca )  1 roll ;
: rot      ( abc -- bca )  2 roll ;
: rot>     ( abc -- cab )  rot rot ;
: tuck     (  ab -- bab )  swap over ;
: nip      (  ab -- b   )  swap drop ;

: do       (   q --     )  @TRUE swap if ;
: dip      (  vq -- v   )  swap !_d do @_d ;
: sip      (  vq -- v   )  !_s dup @_s swap [do] dip ;
: bi       ( xqq --     )  [sip] dip do ;
: bi*      (xyqq --     )  [dip] dip do ;
: bi@      ( xyq --     )  dup bi* ;

: until (q-)
	[ |begin
		dup dip
		swap not ?ret
		drop &|begin ?jump
	] do
	drop
;

: =        (  ab -- c   )  cmp not ;
: <>       (  ab -- c   )  = not ;
: <        (  ab -- c   )  cmp -1 = ;
: <=       (  ab -- c   )  < not ;
: >        (  ab -- c   )  cmp 1 = ;
: >=       (  ab -- c   )  > not ;
: 0=       (   a -- c   )  0 = ;
: 0<>      (   a -- c   )  0 <> ;
: 0<       (   a -- c   )  0 < ;
: 0>       (   a -- c   )  0 > ;
: 0>=      (   a -- c   )  0 >= ;
: ><       ( nlh -- c   )  2 pick >  rot> >  band ;
: =><=     ( nlh -- c   )  2 pick >= rot> >= band ;

: reset    ( xya --     )  [drop depth 0=] until ;

: 1+       (   a -- c   )  1 + ;
: 1-       (   a -- c   )  1 - ;
: 2+       (   a -- c   )  2 + ;
: 2-       (   a -- c   )  2 - ;

: /        (  ab -- c   )  /mod swap drop ;
: mod      (  ab -- d   )  /mod drop ;
: even?    (   n -- f   )  2 mod 0= ;
: odd?     (   n -- f   )  even? not ;
: integral (   f -- n   )  0 bxor ;
: negate   (  ab -- d   )  -1  * ;
: abs      (   a -- c   )  dup 0< [negate] if ;
: square   (  ab -- d   )  dup * ;
: min      (  am -- c   )  2dup < [nip] [drop] cond ;
: max      (  aM -- c   )  2dup > [nip] [drop] cond ;
: clamp    ( amM -- c   )  2 pick swap max swap min swap drop ;

: cr       (     --     )  10 emit ;

10 !BASE
: decimal 10 !BASE ;
: hex     16 !BASE ;

: .n ( n -- )
	dup 0< [ $- emit -1 * ] if
	?dup 0= [
		$0 emit
	] [
		999 swap  (stop indicator)
		[
			@BASE /mod             (r q)
			integral swap integral (q r)
			dup 9 >
				[ 10 - $a + ]
				[ $0 + ]
			cond
		swap ?dup not ] until
		[ emit dup 999 = ] until
	] cond
;

3735928559 !_RAND
: rand (range-)
	@_RAND 11109 * 13849 +
	524287 band 1 bshr
	dup !_RAND
;
