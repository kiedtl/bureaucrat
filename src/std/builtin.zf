1 !TRUE
0 !FALSE

word cond : <aqq->
	!_a !_b !_f
	@_f not @_a if
	@_f @_b if
;;

word over  :  ( abc -- bca )  1 pick ;;
word 2drop :  (  ab -- b   )  drop drop ;;
word dup   :  ( abc -- bca )  0 pick ;;
word ?dup  :  ( abc -- bca )  dup [ dup ] if ;;
word 2dup  :  ( abc -- bca )  over over ;;
word swap  :  ( abc -- bca )  1 roll ;;
word rot   :  ( abc -- bca )  2 roll ;;
word rot>  :  ( abc -- cab )  rot rot ;;
word tuck  :  (  ab -- bab )  swap over ;;
word nip   :  (  ab -- b   )  swap drop ;;

word do    :  (   q --     )  @TRUE swap if ;;
word dip   :  (  vq -- v   )  swap push do pop ;;
word sip   :  (  vq -- v   )  push dup pop swap [ do ] dip ;;
word bi    :  ( xqq --     )  [ sip ] dip do ;;
word bi*   :  (xyqq --     )  [ dip ] dip do ;;
word bi@   :  ( xyq --     )  dup bi* ;;

word =     :  (  ab -- c   )  cmp not ;;
word <>    :  (  ab -- c   )  = not ;;
word <     :  (  ab -- c   )  cmp -1 = ;;
word >     :  (  ab -- c   )  cmp 1 = ;;
word <=    :  (  ab -- c   )  > not ;;
word >=    :  (  ab -- c   )  < not ;;
word 0=    :  (   a -- c   )  0 = ;;
word 0<>   :  (   a -- c   )  0 <> ;;
word 0<    :  (   a -- c   )  0 < ;;
word 0>    :  (   a -- c   )  0 > ;;
word 0>=   :  (   a -- c   )  0 >= ;;
word 0<=   :  (   a -- c   )  0 <= ;;
word ><    :  ( nlh -- c   )  2 pick >  rot> >  band ;;
word =><=  :  ( nlh -- c   )  2 pick >= rot> >= band ;;

word until : <q-*>
	[ dup dip swap ?ret again ] do
	drop
;;

word reset :  ( xya --     )  [ drop depth 0= ] until ;;

word 1+    :  (   a -- c   )  1 + ;;
word 1-    :  (   a -- c   )  1 - ;;
word 2+    :  (   a -- c   )  2 + ;;
word 2-    :  (   a -- c   )  2 - ;;

word /     :  (  ab -- c   )  /mod swap drop ;;
word mod   :  (  ab -- d   )  /mod drop ;;
word fact  :  (   n -- n   )  dup 1 <= ?ret dup 1- fact * ;;
\word pow   :  (  bp -- n   )  1 swap [ over * ] times nip ;;

( TODO )
word sqrt : <n-n>
	1
	[
		2dup / over - 2 /

		\ TODO: intead of comparing with 0, compare for equality with
		\ the previous iteration's value. This is to prevent infinite
		\ loops on inputs such as 232.
		dup 0= ?ret

		+
		again
	] do
	drop nip
;;

\ this uses the machin formula
\ pi = (4 * arctangent(1/5) - arctangent(1/239)) * 4
word pi     : (     -- n   )  4 1 5 / atan * 1 239 / atan - 4 * ;;

\
\         inf
\         ___  1
\ e = 1 + \   ───
\         /__ +n!
\         n=0
\
18 !E_ITERS
word e_iter : <nn-nn> ( iters accm -- )
	[ swap 1- swap over fact 1 swap / + over 1 = ] until
;;
word e      : (     -- n   ) @E_ITERS 0 e_iter nip 1 + ;;

\pi !PI
\e  !E

word even?  : (   n -- f   )  2 mod 0= ;;
word odd?   : (   n -- f   )  even? not ;;
word int    : (   f -- n   )  0 bxor ;;
word negate : (  ab -- d   )  -1  * ;;
word abs    : (   a -- c   )  dup 0< [ negate ] if ;;
word square : (  ab -- d   )  dup * ;;
word min    : (  am -- c   )  2dup < [ nip ] [ drop ] cond ;;
word max    : (  aM -- c   )  2dup > [ nip ] [ drop ] cond ;;
word clamp  : ( amM -- c   )  2 pick swap max swap min swap drop ;;

word cr     : (     --     )  10 emit ;;

10 !BASE
word decimal : 10 !BASE ;;
word hex     : 16 !BASE ;;

word .n : <n->
	dup 0< [ $- emit -1 * ] if
	?dup 0= [
		$0 emit
	] [
		999 swap (stop indicator)
		[
			@BASE /mod             (r q)
			int swap int (q r)
			dup 9 >
				[ 10 - $a + ]
				[ $0 + ]
			cond
		swap ?dup not ] until
		[ emit dup 999 = ] until
		drop    (drop stop indicator)
	] cond
;;

3735928559 !_RAND
word rand : <n->
	@_RAND 11109 * 13849 +
	524287 band 1 bshr
	dup !_RAND
;;
