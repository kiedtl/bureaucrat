0 0= !TRUE
1 0= !FALSE

'cond (fqq-) [
  !_a !_b !_f
  @_f @_a if
  @_f not @_b if
] proc

'reset  ( xya --    )  [ depth [drop depth] while           ] proc
'over   ( abc -- bca)  [ 1 pick                             ] proc
'2drop  (  ab -- b  )  [ drop drop                          ] proc
'dup    ( abc -- bca)  [ 0 pick                             ] proc
'2dup   ( abc -- bca)  [ over over                          ] proc
'swap   ( abc -- bca)  [ 1 roll                             ] proc
'rot    ( abc -- bca)  [ 2 roll                             ] proc
'rot>   ( abc -- cab)  [ rot rot                            ] proc
'tuck   (  ab -- bab)  [ swap over                          ] proc
'nip    (  ab -- b  )  [ swap drop                          ] proc
 
'do     (   q --    )  [ @TRUE swap if                      ] proc
'dip    (  vq -- v  )  [ swap !_d do @_d                    ] proc
'sip    (  vq -- v  )  [ !_s dup @_s swap [do] dip          ] proc
'bi     ( xqq --    )  [ [sip] dip do                       ] proc
'bi*    (xyqq --    )  [ [dip] dip do                       ] proc
'bi@    ( xyq --    )  [ dup bi*                            ] proc
 
'=      (  ab -- c  )  [ cmp not                            ] proc
'<      (  ab -- c  )  [ cmp -1 =                           ] proc
'<=     (  ab -- c  )  [ < not                              ] proc
'>      (  ab -- c  )  [ cmp 1 =                            ] proc
'>=     (  ab -- c  )  [ > not                              ] proc
'><     ( nlh -- c  )  [ 2 pick >  rot> >  b&               ] proc
'=><=   ( nlh -- c  )  [ 2 pick >= rot> >= b&               ] proc
'0=     (   a -- c  )  [ 0 =                                ] proc
'0<>    (   a -- c  )  [ 0 <>                               ] proc
'0<     (   a -- c  )  [ 0 <                                ] proc
'0>     (   a -- c  )  [ 0 >                                ] proc
'0>=    (   a -- c  )  [ 0 >=                               ] proc
 
'1+     (   a -- c  )  [ 1 +                                ] proc
'1-     (   a -- c  )  [ 1 -                                ] proc
'2+     (   a -- c  )  [ 2 +                                ] proc
'2-     (   a -- c  )  [ 2 -                                ] proc
'/      (  ab -- c  )  [ /mod swap drop                     ] proc
'mod    (  ab -- d  )  [ /mod drop                          ] proc
 
'even?  (   n -- f  )  [ 2 mod 0=                           ] proc
'odd?   (   n -- f  )  [ even? not                          ] proc
 
'abs    (   a -- c  )  [ dup 0< [negate] if                 ] proc
'square (  ab -- d  )  [ dup *                              ] proc
'negate (  ab -- d  )  [ -1  *                              ] proc
'min    (  am -- c  )  [ 2dup < [drop] [nip] cond           ] proc
'max    (  aM -- c  )  [ 2dup > [drop] [nip] cond           ] proc
'clamp  ( amM -- c  )  [ 2 pick swap max swap min swap drop ] proc
